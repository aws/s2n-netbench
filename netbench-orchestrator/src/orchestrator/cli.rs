// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

use crate::orchestrator::{OrchError, OrchResult};
use serde::Deserialize;
use std::{
    fs::File,
    path::{Path, PathBuf},
};

#[derive(Clone, Debug)]
pub struct OrchestratorConfig {
    // netbench
    netbench_scenario_filename: String,
    netbench_scenario_filepath: PathBuf,

    // cdk
    pub cdk_config: CdkConfig,
}

// Used for parsing the scenario file generated by the s2n-netbench project
#[derive(Clone, Debug, Default, Deserialize)]
pub struct CdkConfig {
    #[serde(rename(deserialize = "NetbenchInfraPrimaryProd"))]
    resources: CdkResources,
}

#[derive(Clone, Debug, Default, Deserialize)]
#[serde(rename_all(deserialize = "camelCase"))]
struct CdkResources {
    // CloudWatch log group name
    output_netbench_runner_log_group: String,
    // public netbench s3 bucket
    //
    // Used for storing artifacts for the orchestrator and netbench runs
    output_netbench_runner_public_logs_bucket: String,
    // private netbench s3 bucket
    //
    // Used for storing source based netbench drivers which could be private
    output_netbench_runner_private_src_bucket: String,
    // CloudFront stack which serves the netbench reports
    output_netbench_cloudfront_distribution: String,
    // EC2 instance profile for orchestrator hosts
    output_netbench_runner_instance_profile: String,
    // Subnet tag/key values
    //
    // The orchestrator supports multi-AZ runs and expects the a provisioned
    // subnet per AZ. We discover these subnets via a tag key/value pair, which
    // should be the same for all Subnets.
    output_netbench_subnet_tag_key: String,
    output_netbench_subnet_tag_value: String,
    // AWS region where the netbench orchestrator will run
    output_netbench_infra_primary_prod_region: String,
}

impl OrchestratorConfig {
    pub fn netbench_scenario_filename(&self) -> &str {
        &self.netbench_scenario_filename
    }

    pub fn netbench_scenario_file_stem(&self) -> &str {
        self.netbench_scenario_filepath
            .as_path()
            .file_stem()
            .expect("expect scenario file")
            .to_str()
            .unwrap()
    }

    pub fn cf_url(&self, unique_id: &str) -> String {
        format!(
            "{}/{}",
            self.cdk_config.netbench_cloudfront_distribution(),
            unique_id
        )
    }

    pub fn s3_path(&self, unique_id: &str) -> String {
        format!(
            "s3://{}/{}",
            self.cdk_config.netbench_runner_public_s3_bucket(),
            unique_id
        )
    }

    pub fn s3_private_path(&self, unique_id: &str) -> String {
        format!(
            "s3://{}/{}",
            self.cdk_config.netbench_runner_private_s3_bucket(),
            unique_id
        )
    }
}

impl CdkConfig {
    pub fn netbench_runner_public_s3_bucket(&self) -> &String {
        &self.resources.output_netbench_runner_public_logs_bucket
    }

    pub fn netbench_runner_private_s3_bucket(&self) -> &String {
        &self.resources.output_netbench_runner_private_src_bucket
    }

    pub fn netbench_cloudfront_distribution(&self) -> &String {
        &self.resources.output_netbench_cloudfront_distribution
    }

    pub fn netbench_runner_log_group(&self) -> &String {
        &self.resources.output_netbench_runner_log_group
    }

    pub fn netbench_runner_instance_profile(&self) -> &String {
        &self.resources.output_netbench_runner_instance_profile
    }

    pub fn netbench_runner_subnet_tag_key(&self) -> String {
        // https://docs.rs/aws-sdk-ec2/latest/aws_sdk_ec2/operation/describe_subnets/builders/struct.DescribeSubnetsFluentBuilder.html#method.filters
        // "EC2 api requires the `tag:` prefix when specifying tags"
        format!("tag:{}", self.resources.output_netbench_subnet_tag_key)
    }

    pub fn netbench_runner_subnet_tag_value(&self) -> &String {
        &self.resources.output_netbench_subnet_tag_value
    }

    pub fn netbench_primary_region(&self) -> &String {
        &self.resources.output_netbench_infra_primary_prod_region
    }

    fn from_file(cdk_config_file: &PathBuf) -> OrchResult<Self> {
        let path = Path::new(&cdk_config_file);
        let cdk_config_file = File::open(path).map_err(|_err| OrchError::Init {
            dbg: format!("Scenario file not found: {:?}", path),
        })?;
        let config: CdkConfig = serde_json::from_reader(cdk_config_file).unwrap();
        Ok(config)
    }
}
